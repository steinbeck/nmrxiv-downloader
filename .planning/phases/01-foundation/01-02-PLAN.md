---
phase: 01-foundation
plan: 02
type: execute
---

<objective>
Create nmrxiv API client and wire it to CLI for basic connectivity.

Purpose: Establish communication with nmrxiv.org API, validate our understanding of the endpoints, and prove end-to-end connectivity.
Output: Working `nmrxiv list` and `nmrxiv show` commands that return real data from nmrxiv.org.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md

**nmrxiv API (from RESEARCH.md):**
- Base URL: https://nmrxiv.org/api/v1
- GET /v1/list/{model} - List items (project, study, dataset)
- GET /v1/{id} - Get item by identifier
- No auth required for read operations

**Patterns to follow (from RESEARCH.md):**
- API client class with httpx
- Pydantic models for responses
- Structured JSON error output
- Explicit timeouts on all HTTP calls

**Don't hand-roll:**
- HTTP requests → use httpx
- Response validation → use Pydantic
- Progress bars → use rich.progress (for future downloads)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Pydantic models for API responses</name>
  <files>nmrxiv_downloader/models.py</files>
  <action>
Create Pydantic models for nmrxiv API responses:

1. Create `nmrxiv_downloader/models.py` with:
   - Base model with ConfigDict for flexible parsing (extra="ignore")
   - Project model: id, name, description, identifier, created_at, updated_at
   - Study model: id, name, description, sample_info, project_id
   - Dataset model: id, name, description, type, format, study_id
   - All fields should be Optional where API might not return them
   - Use datetime for date fields

2. Add a generic ListResponse model for paginated results

3. Use snake_case in Python, but allow alias for API's camelCase if needed

Keep models minimal — we'll expand as we learn more about the actual API responses.
  </action>
  <verify>python -c "from nmrxiv_downloader.models import Project, Study, Dataset; print('Models OK')"</verify>
  <done>Models importable, Pydantic validation works</done>
</task>

<task type="auto">
  <name>Task 2: Create httpx API client class</name>
  <files>nmrxiv_downloader/client.py</files>
  <action>
Create API client following patterns from RESEARCH.md:

1. Create `nmrxiv_downloader/client.py` with NmrXivClient class:
   - BASE_URL = "https://nmrxiv.org/api/v1"
   - __init__ with configurable timeout (default 30s)
   - httpx.Client with base_url, timeout, headers={"Accept": "application/json"}

2. Implement methods:
   - list_projects() -> list[Project]: GET /list/project
   - list_studies() -> list[Study]: GET /list/study
   - list_datasets() -> list[Dataset]: GET /list/dataset
   - get_item(item_id: str) -> dict: GET /{id}

3. Error handling:
   - Catch httpx.HTTPStatusError, httpx.RequestError
   - Raise custom NmrXivError with message and status code
   - Create NmrXivError exception class in same file

4. Add context manager support (__enter__, __exit__) for proper client cleanup

Do NOT implement search yet — that's Phase 2.
  </action>
  <verify>python -c "from nmrxiv_downloader.client import NmrXivClient; c = NmrXivClient(); print(len(c.list_projects()))"</verify>
  <done>Client can connect to nmrxiv.org and retrieve project list</done>
</task>

<task type="auto">
  <name>Task 3: Wire CLI to client, add list and show commands</name>
  <files>nmrxiv_downloader/cli.py, nmrxiv_downloader/output.py</files>
  <action>
Update CLI to use the API client:

1. Create `nmrxiv_downloader/output.py` with:
   - output_json(data, pretty=True) - JSON to stdout
   - output_error(message, code=1) - Error JSON to stderr + exit
   - output_table(data, columns) - Rich table for human output (optional, use if --no-json)

2. Update `nmrxiv_downloader/cli.py`:
   - Add `list` command with --type option (project/study/dataset)
   - Update `show` command to take item_id argument and fetch real data
   - Keep `search` and `download` as stubs for now
   - Use output_json() for all JSON output
   - Use output_error() for all errors
   - Wrap API calls in try/except for NmrXivError

3. JSON output format for list:
   {"items": [...], "count": N, "type": "project|study|dataset"}

4. JSON output format for show:
   {"item": {...}, "id": "..."}

5. JSON output format for errors:
   {"error": true, "message": "...", "code": N}

Test with real API calls to nmrxiv.org.
  </action>
  <verify>nmrxiv list --type project | python -c "import sys,json; d=json.load(sys.stdin); print(f'Found {d[\"count\"]} projects')"</verify>
  <done>CLI connects to real API, list and show commands work, JSON output valid</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `nmrxiv list --type project` returns real projects from nmrxiv.org
- [ ] `nmrxiv list --type dataset` returns real datasets
- [ ] `nmrxiv show <some-id>` returns item details (find ID from list output)
- [ ] All output is valid JSON (pipe to `python -m json.tool`)
- [ ] Errors return JSON to stderr with proper exit code
- [ ] `nmrxiv --help` shows updated command descriptions
</verification>

<success_criteria>

- All tasks completed
- API client connects to nmrxiv.org successfully
- list command returns real data
- show command returns real item details
- JSON output parseable by Claude Code
- Errors are structured JSON
- Phase 1 complete
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`

Then update:
- .planning/STATE.md (mark Phase 1 complete)
- .planning/ROADMAP.md (check off Phase 1)
</output>
